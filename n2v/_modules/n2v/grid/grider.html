<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>n2v :: n2v.grid.grider</title>
  

  <link rel="icon" type="image/png" sizes="32x32" href="../../../_static/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../_static/img/favicon-16x16.png">
  <link rel="index" title="Index" href="../../../genindex.html"/>

  <link rel="stylesheet" href="../../../_static/css/insegel.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="insegel-container">
    <header>
      <div id="logo-container">
          
          <a href="../../../index.html"><img src="../../../_static/logo_nameless_png.png"></a>
          
      </div>
      <div id="project-container">
        
        <h1>n2v Documentation</h1>
        
      </div>
    </header>

    <div id="content-container">

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for n2v.grid.grider</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">grider.py</span>

<span class="sd">Generates grid for plotting </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">opt_einsum</span> <span class="kn">import</span> <span class="n">contract</span>
<span class="kn">import</span> <span class="nn">psi4</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">be_quiet</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pylibxc</span> <span class="kn">import</span> <span class="n">LibXCFunctional</span> <span class="k">as</span> <span class="n">Functional</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">.cubeprop</span> <span class="kn">import</span> <span class="n">Cubeprop</span>
<span class="kn">from</span> <span class="nn">.basis_set_artifact_correction</span> <span class="kn">import</span> <span class="n">basis_set_correction</span><span class="p">,</span> <span class="n">invert_kohn_sham_equations</span>

<div class="viewcode-block" id="Grider"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider">[docs]</a><span class="k">class</span> <span class="nc">Grider</span><span class="p">(</span><span class="n">Cubeprop</span><span class="p">):</span>

<div class="viewcode-block" id="Grider.grid_to_blocks"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.grid_to_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">grid_to_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate list of blocks to allocate given grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: np.ndarray</span>
<span class="sd">            Grid to be distributed into blocks</span>
<span class="sd">            Size: (3, npoints) for homogeneous grid</span>
<span class="sd">                  (4, npoints) for inhomogenous grid to account for weights</span>
<span class="sd">        basis: psi4.core.BasisSet; optional</span>
<span class="sd">            The basis set. If not given, it will use target wfn.basisset().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocks: list    </span>
<span class="sd">            List with psi4.core.BlockOPoints</span>
<span class="sd">        npoints: int</span>
<span class="sd">            Total number of points (for one dimension)</span>
<span class="sd">        points: psi4.core.{RKS, UKS}</span>
<span class="sd">            Points function to set matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;Grid does not have the correct dimensions. </span><span class="se">\n</span><span class="s2"></span>
<span class="s2">                                                              Array must be of size (3, npoints) or (4, npoints)&quot;&quot;&quot;</span>
        <span class="n">if_w</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span>

        <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span>

        <span class="n">epsilon</span>    <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">get_global_option</span><span class="p">(</span><span class="s2">&quot;CUBIC_BASIS_TOLERANCE&quot;</span><span class="p">)</span>
        <span class="n">extens</span>     <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">BasisExtents</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="n">max_points</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">get_global_option</span><span class="p">(</span><span class="s2">&quot;DFT_BLOCK_MAX_POINTS&quot;</span><span class="p">)</span>        
        <span class="n">npoints</span>    <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">npoints</span><span class="o">/</span><span class="n">max_points</span><span class="p">))</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">max_functions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#Run through full blocks</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">max_points</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">max_points</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">max_points</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">if_w</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">max_points</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_points</span><span class="p">))</span>  <span class="c1"># When w is not necessary and not given</span>

            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">BlockOPoints</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">extens</span><span class="p">))</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">max_points</span>
            <span class="n">max_functions</span> <span class="o">=</span> <span class="n">max_functions</span> <span class="k">if</span> <span class="n">max_functions</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span> \
                                          <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>

        <span class="c1">#Run through remaining points</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">:])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">:])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">idx</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">if_w</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">idx</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">idx</span><span class="p">:]))</span>  <span class="c1"># When w is not necessary and not given</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">BlockOPoints</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">extens</span><span class="p">))</span>

            <span class="n">max_functions</span> <span class="o">=</span> <span class="n">max_functions</span> <span class="k">if</span> <span class="n">max_functions</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span> \
                                          <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>

        <span class="n">zero_matrix</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">nbf</span><span class="p">(),</span> <span class="n">basis</span><span class="o">.</span><span class="n">nbf</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">point_func</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">RKSFunctions</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">max_points</span><span class="p">,</span> <span class="n">max_functions</span><span class="p">)</span>
            <span class="n">point_func</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">zero_matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">point_func</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">UKSFunctions</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">max_points</span><span class="p">,</span> <span class="n">max_functions</span><span class="p">)</span>
            <span class="n">point_func</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">zero_matrix</span><span class="p">,</span> <span class="n">zero_matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">point_func</span></div>

<div class="viewcode-block" id="Grider.generate_grids"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.generate_grids">[docs]</a>    <span class="k">def</span> <span class="nf">generate_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Genrates Mesh from 3 separate linear spaces and flatten,</span>
<span class="sd">        needed for cubic grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: tuple of three np.ndarray</span>
<span class="sd">            (x, y, z)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grid: np.ndarray</span>
<span class="sd">            shape (3, len(x)*len(y)*len(z)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x,y,z, = grid</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">shape</span></div>

<div class="viewcode-block" id="Grider.generate_dft_grid"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.generate_dft_grid">[docs]</a>    <span class="k">def</span> <span class="nf">generate_dft_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vpot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts DFT spherical grid and weights from wfn object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpot object with dft grid data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dft_grid: list</span>
<span class="sd">            Numpy arrays corresponding to x,y,z, and w.</span>
<span class="sd">            Shape: (4, npoints)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>

        <span class="n">dft_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">npoints</span><span class="p">))</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>

            <span class="n">dft_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">x</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>
            <span class="n">dft_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">y</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>
            <span class="n">dft_grid</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">z</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>
            <span class="n">dft_grid</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>

        <span class="k">return</span> <span class="n">dft_grid</span></div>

    <span class="c1">#Quantities on Grid</span>
<div class="viewcode-block" id="Grider.on_grid_ao"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_ao">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_ao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a quantity on the grid given its ao representation.</span>
<span class="sd">        *This is the most general function for basis to grid transformation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeff: np.ndarray</span>
<span class="sd">            Vector/Matrix of quantity on ao basis. Shape: {(num_ao_basis, ), (num_ao_basis, num_ao_basis)}</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        basis: psi4.core.BasisSet, optional</span>
<span class="sd">            The basis set. If not given it will use target wfn.basisset().</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid. </span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coeff_r: np.ndarray Shape: (npoints, )</span>
<span class="sd">            Quantity expressed by the coefficient on the given grid </span>


<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of grid should be (3, npoints) &quot;</span>
                                     <span class="s2">&quot;or (4, npoints) but got (</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">points_function</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="n">coeff_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">))</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">i_block</span><span class="p">)</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
            <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_block</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpos</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l_mat</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[(</span><span class="n">lpos</span><span class="p">[:])]</span>
                <span class="n">coeff_r</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">contract</span><span class="p">(</span><span class="s1">&#39;pm,m-&gt;p&#39;</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">l_mat</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">coeff</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">l_mat</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[(</span><span class="n">lpos</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">lpos</span><span class="p">)]</span>
                <span class="n">coeff_r</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">contract</span><span class="p">(</span><span class="s1">&#39;pm,mn,pn-&gt;p&#39;</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">l_mat</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coeff_r</span></div>

<div class="viewcode-block" id="Grider.on_grid_density"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_density">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">Da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                              <span class="n">Db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates Density given grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Da, Db: np.ndarray</span>
<span class="sd">            Alpha, Beta densities. Shape: (num_ao_basis, num_ao_basis)</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        density: np.ndarray Shape: (ref, npoints)</span>
<span class="sd">            Density on the given grid. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Da</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Da</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">Db</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Da</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Da</span><span class="p">)</span>
            <span class="n">Db</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Db</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">Db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Db is required for an unrestricted system&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of grid should be (3, npoints) &quot;</span>
                                     <span class="s2">&quot;or (4, npoints) but got (</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">points_function</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Da</span><span class="p">)</span>
            <span class="n">rho_a</span> <span class="o">=</span> <span class="n">points_function</span><span class="o">.</span><span class="n">point_values</span><span class="p">()[</span><span class="s2">&quot;RHO_A&quot;</span><span class="p">]</span>
            <span class="n">density</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Da</span><span class="p">,</span> <span class="n">Db</span><span class="p">)</span>
            <span class="n">rho_a</span> <span class="o">=</span> <span class="n">points_function</span><span class="o">.</span><span class="n">point_values</span><span class="p">()[</span><span class="s2">&quot;RHO_A&quot;</span><span class="p">]</span>
            <span class="n">rho_b</span> <span class="o">=</span> <span class="n">points_function</span><span class="o">.</span><span class="n">point_values</span><span class="p">()[</span><span class="s2">&quot;RHO_B&quot;</span><span class="p">]</span>
            <span class="n">density</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">))</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">i_block</span><span class="p">)</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">density</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_a</span><span class="o">.</span><span class="n">np</span><span class="p">[</span> <span class="p">:</span><span class="n">b_points</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">density</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_a</span><span class="o">.</span><span class="n">np</span><span class="p">[</span> <span class="p">:</span><span class="n">b_points</span><span class="p">]</span>
                <span class="n">density</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_b</span><span class="o">.</span><span class="n">np</span><span class="p">[</span> <span class="p">:</span><span class="n">b_points</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">density</span></div>

<div class="viewcode-block" id="Grider.on_grid_orbitals"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_orbitals">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Cb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates orbitals given grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ca, Cb: np.ndarray</span>
<span class="sd">            Alpha, Beta Orbital Coefficient Matrix. Shape: (num_ao_basis, num_ao_basis)</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        orbitals: np.ndarray</span>
<span class="sd">            Orbitals on the given grid of size . </span>
<span class="sd">            Shape: (nbasis, npoints, ref)</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Ca</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Cb</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Db is required for an unrestricted system&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of grid should be (3, npoints) &quot;</span>
                                     <span class="s2">&quot;or (4, npoints) but got (</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">points_function</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">orbitals_r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Ca_np</span> <span class="o">=</span> <span class="n">Ca</span><span class="o">.</span><span class="n">np</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">orbitals_r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">)</span>
            <span class="n">Ca_np</span> <span class="o">=</span> <span class="n">Ca</span><span class="o">.</span><span class="n">np</span>
            <span class="n">Cb_np</span> <span class="o">=</span> <span class="n">Cb</span><span class="o">.</span><span class="n">np</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">i_block</span><span class="p">)</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
            <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_block</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpos</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">):</span>
                <span class="n">Ca_local</span> <span class="o">=</span> <span class="n">Ca_np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">orbitals_r</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">contract</span><span class="p">(</span><span class="s1">&#39;m, pm -&gt; p&#39;</span><span class="p">,</span> <span class="n">Ca_local</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Cb_local</span> <span class="o">=</span> <span class="n">Cb_np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">]</span>
                    <span class="n">orbitals_r</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">contract</span><span class="p">(</span><span class="s1">&#39;m, pm -&gt; p&#39;</span><span class="p">,</span> <span class="n">Ca_local</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
                    <span class="n">orbitals_r</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">contract</span><span class="p">(</span><span class="s1">&#39;m, pm -&gt; p&#39;</span><span class="p">,</span> <span class="n">Cb_local</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>




        <span class="k">return</span> <span class="n">orbitals_r</span></div>

<div class="viewcode-block" id="Grider.on_grid_esp"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_esp">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_esp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wfn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates EXTERNAL/ESP/HARTREE and Fermi Amaldi Potential on given grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Da,Db: np.ndarray, opt, shape (nbf, nbf)</span>
<span class="sd">            The electron density in the denominator of Hartee potential. If None, the original density matrix</span>
<span class="sd">            will be used.</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vext, hartree, esp, v_fa: np.ndarray</span>
<span class="sd">            External, Hartree, ESP, and Fermi Amaldi potential on the given grid</span>
<span class="sd">            Shape: (npoints, )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfn</span>

        <span class="k">if</span> <span class="n">Da</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Da_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wfn</span><span class="o">.</span><span class="n">Da</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">)</span>
            <span class="n">Db_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wfn</span><span class="o">.</span><span class="n">Db</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Da</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wfn</span><span class="o">.</span><span class="n">Da</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Da</span>
            <span class="k">if</span> <span class="n">Db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wfn</span><span class="o">.</span><span class="n">Db</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Db</span>

        <span class="n">nthreads</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">()</span>
        <span class="n">psi4</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="c1">#Initialize Arrays</span>
        <span class="n">vext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
        <span class="n">esp</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>

        <span class="c1">#Get Atomic Information</span>
        <span class="n">mol_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">to_schema</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;psi4&#39;</span><span class="p">)</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol_dict</span><span class="p">[</span><span class="s2">&quot;elem&quot;</span><span class="p">])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
        <span class="c1">#Atomic numbers and Atomic positions</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mol_dict</span><span class="p">[</span><span class="s2">&quot;elez&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span><span class="p">]</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span><span class="p">]</span>

        <span class="n">esp_wfn</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">ESPPropCalc</span><span class="p">(</span><span class="n">wfn</span><span class="p">)</span>

        <span class="c1">#Loop Through blocks</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
                <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">x</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">y</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">z</span><span class="p">()</span><span class="o">.</span><span class="n">np</span>

                <span class="c1">#EXTERNAL</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">vext_temp</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">zs</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span>
                    <span class="n">vext_temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">vext_temp</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">vext</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vext_temp</span>
                <span class="c1">#ESP</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">z</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">grid_block</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
                <span class="n">esp</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">esp_wfn</span><span class="o">.</span><span class="n">compute_esp_over_grid_in_memory</span><span class="p">(</span><span class="n">grid_block</span><span class="p">)</span><span class="o">.</span><span class="n">np</span>

        <span class="c1">#Hartree</span>
        <span class="n">hartree</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">vext</span> <span class="o">+</span> <span class="n">esp</span><span class="p">)</span>
        <span class="n">v_fa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nalpha</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbeta</span><span class="p">))</span> <span class="o">*</span> <span class="n">hartree</span>

        <span class="k">if</span> <span class="n">Da</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wfn</span><span class="o">.</span><span class="n">Da</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Da_temp</span>
        <span class="k">if</span> <span class="n">Db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wfn</span><span class="o">.</span><span class="n">Db</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Db_temp</span>
        <span class="n">psi4</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vext</span><span class="p">,</span> <span class="n">hartree</span><span class="p">,</span> <span class="n">v_fa</span><span class="p">,</span> <span class="n">esp</span></div>

<div class="viewcode-block" id="Grider.on_grid_vxc"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_vxc">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_vxc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Da</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates Vxc given grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Da, Db: np.ndarray</span>
<span class="sd">            Alpha, Beta densities. Shape: (num_ao_basis, num_ao_basis)</span>
<span class="sd">        func_id: int</span>
<span class="sd">            Functional ID associated with Density Functional Approximationl.</span>
<span class="sd">            Full list of functionals: https://www.tddft.org/programs/libxc/functionals/</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        VXC: np.ndarray</span>
<span class="sd">            Exchange correlation potential on the given grid</span>
<span class="sd">            Shape: (npoints, )</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">func_id</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only LDA fucntionals are supported on the grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Da</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_grid_density</span><span class="p">(</span><span class="n">Da</span><span class="o">=</span><span class="n">Da</span><span class="p">,</span> <span class="n">Db</span><span class="o">=</span><span class="n">Db</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_grid_density</span><span class="p">(</span><span class="n">Da</span><span class="o">=</span><span class="n">Da</span><span class="p">,</span> <span class="n">Db</span><span class="o">=</span><span class="n">Db</span><span class="p">,</span> <span class="n">Vpot</span><span class="o">=</span><span class="n">Vpot</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="n">vxc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">))</span>
        <span class="n">ingredients</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ingredients</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ingredients</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">functional</span> <span class="o">=</span> <span class="n">Functional</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">functional</span> <span class="o">=</span> <span class="n">Functional</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="n">xc_dictionary</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">ingredients</span><span class="p">)</span>
            <span class="n">vxc</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xc_dictionary</span><span class="p">[</span><span class="s1">&#39;vrho&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vxc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grider.on_grid_lap_phi"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_lap_phi">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_lap_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                       <span class="n">Ca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">Cb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates laplacian of molecular orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">       Ca, Cb: np.ndarray</span>
<span class="sd">            Alpha, Beta Orbital Coefficient Matrix. Shape: (num_ao_basis, num_ao_basis)</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lap_phi: List[np.ndarray]. Where array is of shape (npoints, ref)</span>
<span class="sd">            Laplacian of molecular orbitals on the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Ca</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Cb</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Db is required for an unrestricted system&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of grid should be (3, npoints) &quot;</span>
                                     <span class="s2">&quot;or (4, npoints) but got (</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">points_function</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="n">points_function</span><span class="o">.</span><span class="n">set_ansatz</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">lap_phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">)</span>
            <span class="n">lap_phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">i_block</span><span class="p">)</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
            <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_block</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpos</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1">#Obtain subset of phi_@@ matrices</span>
            <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_XX&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_YY&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">lz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_ZZ&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">):</span>
                <span class="n">Ca_local</span> <span class="o">=</span> <span class="n">Ca</span><span class="o">.</span><span class="n">np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">lap_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">lx</span> <span class="o">+</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">lz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Ca_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Cb_local</span> <span class="o">=</span> <span class="n">Cb</span><span class="o">.</span><span class="n">np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
                    <span class="n">lap_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">lx</span> <span class="o">+</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">lz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Ca_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">lap_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">lx</span> <span class="o">+</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">lz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Cb_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lap_phi</span></div>

<div class="viewcode-block" id="Grider.on_grid_grad_phi"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.on_grid_grad_phi">[docs]</a>    <span class="k">def</span> <span class="nf">on_grid_grad_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                       <span class="n">Ca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">Cb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">Vpot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates laplacian of molecular orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">       Ca, Cb: np.ndarray</span>
<span class="sd">            Alpha, Beta Orbital Coefficient Matrix. Shape: (num_ao_basis, num_ao_basis)</span>
<span class="sd">        grid: np.ndarray Shape: (3, npoints) or (4, npoints) or tuple for block_handler (return of grid_to_blocks)</span>
<span class="sd">            grid where density will be computed.</span>
<span class="sd">        Vpot: psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grad_phi: List[np.ndarray]. Where array is of shape (npoints, ref)</span>
<span class="sd">            Gradient of molecular orbitals on the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Ca</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ca</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">Cb</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">Cb</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">Cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Db is required for an unrestricted system&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of grid should be (3, npoints) &quot;</span>
                                     <span class="s2">&quot;or (4, npoints) but got (</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_to_blocks</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">points_function</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vpot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)]</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">points_function</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A grid or a V_potential (DFT grid) must be given.&quot;</span><span class="p">)</span>

        <span class="n">points_function</span><span class="o">.</span><span class="n">set_ansatz</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">)</span>
            <span class="n">grad_phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">set_pointers</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">)</span>
            <span class="n">grad_phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">)]</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">points_function</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">i_block</span><span class="p">)</span>
            <span class="n">b_points</span> <span class="o">=</span> <span class="n">i_block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">b_points</span>
            <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_block</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpos</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1">#Obtain subset of phi_@ matrix</span>
            <span class="n">gx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_X&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">gy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_Y&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">gz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_function</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI_Z&quot;</span><span class="p">])[:</span><span class="n">b_points</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">i_orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">):</span>
                <span class="n">Ca_local</span> <span class="o">=</span> <span class="n">Ca</span><span class="o">.</span><span class="n">np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">grad_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">gx</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">+</span> <span class="n">gz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Ca_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">Cb_local</span> <span class="o">=</span> <span class="n">Cb</span><span class="o">.</span><span class="n">np</span><span class="p">[</span><span class="n">lpos</span><span class="p">,</span> <span class="n">i_orb</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
                    <span class="n">grad_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">gx</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">+</span> <span class="n">gz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Ca_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">grad_phi</span><span class="p">[</span><span class="n">i_orb</span><span class="p">][</span><span class="n">offset</span> <span class="o">-</span> <span class="n">b_points</span> <span class="p">:</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">gx</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">+</span> <span class="n">gz</span><span class="p">)</span> <span class="o">@</span> <span class="n">Cb_local</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">grad_phi</span></div>

<div class="viewcode-block" id="Grider.dft_grid_to_fock"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.dft_grid_to_fock">[docs]</a>    <span class="k">def</span> <span class="nf">dft_grid_to_fock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">Vpot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For value on DFT spherical grid, Fock matrix is returned.</span>
<span class="sd">        VFock_ij = \int dx \phi_i(x) \phi_j(x) value(x)</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        value: np.ndarray of shape (npoint, ).</span>

<span class="sd">        Vpot:psi4.core.VBase</span>
<span class="sd">            Vpotential object with info about grid.</span>
<span class="sd">            Provides DFT spherical grid. Only comes to play if no grid is given.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        VFock: np.ndarray of shape (nbasis, nbasis)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">VFock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbf</span><span class="p">))</span>
        <span class="n">points_func</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Loop over the blocks</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Vpot</span><span class="o">.</span><span class="n">nblocks</span><span class="p">()):</span>
            <span class="c1"># Obtain block information</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">Vpot</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">points_func</span><span class="o">.</span><span class="n">compute_points</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
            <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">functions_local_to_global</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="n">npoints</span>
                <span class="k">continue</span>
            <span class="c1"># Obtain the grid weight</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">w</span><span class="p">())</span>

            <span class="c1"># Compute phi!</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_func</span><span class="o">.</span><span class="n">basis_values</span><span class="p">()[</span><span class="s2">&quot;PHI&quot;</span><span class="p">])[:</span><span class="n">npoints</span><span class="p">,</span> <span class="p">:</span><span class="n">lpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">Vtmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;pb,p,p,pa-&gt;ab&#39;</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">npoints</span><span class="p">],</span> <span class="n">w</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Add the temporary back to the larger array by indexing, ensure it is symmetric</span>
            <span class="n">VFock</span><span class="p">[(</span><span class="n">lpos</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">lpos</span><span class="p">)]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Vtmp</span> <span class="o">+</span> <span class="n">Vtmp</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="n">npoints</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Did not run through all the points. </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">VFock</span></div>

    <span class="c1">#Miscellaneous</span>
<div class="viewcode-block" id="Grider.get_basis_set_correction"><a class="viewcode-back" href="../../../api/n2v.Grider.html#n2v.Grider.get_basis_set_correction">[docs]</a>    <span class="k">def</span> <span class="nf">get_basis_set_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">basis_set_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>    </div></div>
</pre></div>

        </div>
      </div>

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search..." />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">

          
  
    
  
  
    <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html"><strong>Installation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../first_steps.html"><strong>First Steps</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../on_the_grid.html"><strong>On the Grid</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html"><strong>API Documentation</strong></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#module-n2v">n2v Package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#class-inheritance-diagram">Class Inheritance Diagram</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  


        </div>

        

      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            

            
        </ul>

        
            <div id="copyright">
                &copy; 2020, Wasserman Group. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.5
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/Autophagy/insegel">Insegel</a>

        </div>
    </div>

    <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

    <script type="text/javascript">
      $("#menu-toggle").click(function() {
        $("#menu-toggle").toggleClass("toggled");
        $("#side-menu-container").slideToggle(300);
      });
    </script>

</footer> 

</div>

</body>
</html>